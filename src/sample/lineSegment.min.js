(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Angle = function () {
    function Angle() {
        var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        _classCallCheck(this, Angle);

        this._angle = angle;
        this._radian = angle * Angle.ANGLE_TO_RADIAN;
    }

    _createClass(Angle, [{
        key: "angle",
        set: function set(value) {
            this._angle = value;
            this._radian = value * Angle.ANGLE_TO_RADIAN;
        },
        get: function get() {
            return this._angle;
        }
    }, {
        key: "radian",
        set: function set(value) {
            this._radian = value;
            this._angle = value * Angle.RADIAN_TO_ANGLE;
        },
        get: function get() {
            return this._radian;
        }

        /**
         * 求锐角
         */

    }, {
        key: "acute",
        get: function get() {
            var a = this._angle;
            while (a > 90) {
                a -= 180;
            }

            while (a < -90) {
                a += 180;
            }
            return a >= 0 ? a : -a;
        }
    }]);

    return Angle;
}();

Angle.ANGLE_TO_RADIAN = Math.PI / 180;
Angle.RADIAN_TO_ANGLE = 180 / Math.PI;
exports.Angle = Angle;
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Line = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by work on 2017/2/16.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Point = require("./Point");

var _Angle = require("./Angle");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Line = function () {
    function Line() {
        _classCallCheck(this, Line);

        //垂直于x轴
        if (arguments.length === 1) {
            this.x = arguments[0];
            this.k = Infinity;
        }
        //k,b
        else if (arguments.length === 2) {
                this.k = arguments[0];
                this.b = arguments[1];
            }
            //x1,y1,x2,y2
            else if (arguments.length === 4) {
                    var x1 = arguments[0];
                    var y1 = arguments[1];
                    var x2 = arguments[2];
                    var y2 = arguments[3];
                    this.k = (y2 - y1) / (x2 - x1);

                    if (this.isVertical) {
                        this.x = x1;
                    } else {
                        this.b = y1 - this.k * x1;
                    }
                } else {
                    throw new Error('arguments number invalid');
                }
        this.range = [-999999999, 999999999];
    }

    /**
     * 获取用于绘图的点
     * @returns {*}
     */


    _createClass(Line, [{
        key: "isPointInLine",


        /**
         * 是否点在直线上
         * @param x
         * @param y
         * @returns {boolean}
         */
        value: function isPointInLine(x, y) {
            if (arguments.length === 1 && (typeof x === "undefined" ? "undefined" : _typeof(x)) === _Point.Point) {
                y = x.y;
                x = x.x;
            }
            if (this.isVertical) {
                return x === this.x;
            }
            return this.k * x + this.b === y;
        }

        /**
         * 获取和另外一条直线的交点
         * @param l
         */

    }, {
        key: "getLineIntersection",
        value: function getLineIntersection(l) {
            //平行
            if (this.k === l.k) {
                return null;
            }
            //两条线中有一条垂直
            else if (this.isVertical || l.isVertical) {
                    return new _Point.Point(this.isVertical ? this.x : l.x, this.isVertical ? l.k * this.x + l.b : this.k * l.x + this.b);
                } else {
                    var k1 = this.k;
                    var b1 = this.b;
                    var k2 = l.k;
                    var b2 = l.b;
                    var x = (b2 - b1) / (k1 - k2);
                    return new _Point.Point(x, k1 * x + b1);
                }
        }

        /**
         * 获取经过指定点的垂线
         * @param x
         * @param y
         * @returns {Line}
         */

    }, {
        key: "getVerticalLine",
        value: function getVerticalLine(x, y) {
            if (this.isVertical) {
                return new Line(0, y);
            }
            if (this.isHorizontal) {
                return new Line(x);
            }
            return new Line(-1 / this.k, y + x / this.k);
        }

        /**
         * 获取经过指定点的垂线交点
         * @param x
         * @param y
         * @returns {*}
         */

    }, {
        key: "getVerticalIntersection",
        value: function getVerticalIntersection(x, y) {
            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);
            var verticalLine = this.getVerticalLine(x, y);
            return this.getLineIntersection(verticalLine);
        }

        /**
         * 获取对称点
         * @param x
         * @param y
         * @returns {Point}
         */

    }, {
        key: "getSymmetryPoint",
        value: function getSymmetryPoint(x, y) {

            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);

            //换算成一般式
            var A = this.k;
            var B = -1;
            var C = this.b;
            var temp = 2 * (A * x + B * y + C) / (A * A + B * B);

            return new _Point.Point(x - A * temp, y - B * temp);
        }

        /**
         * 获取两线夹角（0<=angle<=90）
         * @param l
         * @returns {number}
         */

    }, {
        key: "getIntersectionAngle",
        value: function getIntersectionAngle(l) {
            var angle = new _Angle.Angle();
            //平行
            if (this.k === l.k) {
                return 0;
            }
            //如果有一条直线垂直于x轴，计算出另外一条直线和x轴之间的夹角，然后用90度减去这个夹角
            if (this.isVertical || l.isVertical) {
                angle.radian = Math.atan(Math.abs(this.isVertical ? l.k : this.k));
                return 90 - angle.acute;
            }
            angle.radian = Math.atan(this.k) - Math.atan(l.k);
            return angle.acute;
        }
    }, {
        key: "points",
        get: function get() {
            var p = void 0;
            if (this.isVertical) {
                p = [new _Point.Point(this.x, this.range[0]), new _Point.Point(this.x, this.range[1])];
            } else if (this.isHorizontal) {
                p = [new _Point.Point(this.range[0], this.b), new _Point.Point(this.range[1], this.b)];
            } else {
                p = [new _Point.Point(this.range[0], this.k * this.range[0] + this.b), new _Point.Point(this.range[1], this.k * this.range[1] + this.b)];
            }
            return p;
        }

        /**
         * 垂直
         * @returns {boolean}
         */

    }, {
        key: "isVertical",
        get: function get() {
            return this.k === Infinity || this.k === -Infinity || this.b === Infinity || this.b === -Infinity;
        }

        /**
         * 水平
         * @returns {boolean}
         */

    }, {
        key: "isHorizontal",
        get: function get() {
            return this.k === 0;
        }
    }]);

    return Line;
}();

exports.Line = Line;
},{"./Angle":1,"./Point":4}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineSegment = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Line2 = require("./Line");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by work on 2017/2/17.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var LineSegment = function (_Line) {
  _inherits(LineSegment, _Line);

  function LineSegment(x1, y1, x2, y2) {
    _classCallCheck(this, LineSegment);

    var k = Math.tan((y2 - y1) / (x2 - x1));
    var b = y1 - k * x1;

    var _this = _possibleConstructorReturn(this, (LineSegment.__proto__ || Object.getPrototypeOf(LineSegment)).call(this, k, b));

    _this.range = [Math.min(x1, x2), Math.max(x1, x2)];
    return _this;
  }

  /**
   * 点到线段的距离
   * @param x
   * @param y
   */


  _createClass(LineSegment, [{
    key: "getDistanceFromPoint",
    value: function getDistanceFromPoint(x, y) {}

    /**
     * 线段到线段的距离
     * @param l
     */

  }, {
    key: "getDistanceFromLineSegment",
    value: function getDistanceFromLineSegment(l) {}
  }]);

  return LineSegment;
}(_Line2.Line);

exports.LineSegment = LineSegment;
},{"./Line":2}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by work on 2017/2/21.
 */

var Point = function () {
    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, Point);

        this.setValues(x, y);
    }

    _createClass(Point, [{
        key: "setValues",
        value: function setValues() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            this.x = x;
            this.y = y;
            return this;
        }
    }, {
        key: "copy",
        value: function copy(p) {
            this.x = p.x;
            this.y = p.y;
            return this;
        }

        /**
         * 两点间的直线距离
         * @param p
         * @returns {number}
         */

    }, {
        key: "distance",
        value: function distance(p) {
            var w = p.x - this.x;
            var h = p.y - this.y;
            return Math.sqrt(w * w + h * h);
        }
        /**
         * 返回该点的一个克隆
         * @method clone
         * @return {Point} 克隆之后的Point实例
         **/

    }, {
        key: "clone",
        value: function clone() {
            return new Point(this.x, this.y);
        }
        /**
         * Returns a string representation of this object.
         * @method toString
         * @return {String} a string representation of the instance.
         **/

    }, {
        key: "toString",
        value: function toString() {
            return "[Point (x=" + this.x + " y=" + this.y + ")]";
        }
    }]);

    return Point;
}();

exports.Point = Point;
},{}],5:[function(require,module,exports){
"use strict";

var _Point = require("../coniferCone/geom/Point");

var _LineSegment = require("../coniferCone/geom/LineSegment");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Created by work on 2017/2/21.
                                                                                                                                                           */

/**
 * 交点和角度
 */
var IntersectionAndAngle = function IntersectionAndAngle(intersection, angle) {
    _classCallCheck(this, IntersectionAndAngle);

    this.intersection = intersection;
    this.angle = angle;
};

main();
function main() {

    var canvas = document.getElementsByTagName('canvas')[0];
    var startP = new _Point.Point(),
        endP = new _Point.Point(),
        shape = void 0,
        shapes = new Map();
    //绘制交点
    var intersectionShape = new createjs.Shape();
    //角度文本集合
    var angleContainer = new createjs.Container();

    var data = {
        drawOption: 'lineSegment'
    };

    var ui = new dat.GUI();
    ui.add(data, 'drawOption', ['lineSegment']);

    var stage = new createjs.Stage(canvas);
    createjs.Ticker.setFPS(60);
    createjs.Ticker.addEventListener('tick', stage);

    stage.addChild(intersectionShape);
    stage.addChild(angleContainer);

    stage.addEventListener('stagemousedown', onStageMouseDown);

    function onStageMouseDown(e) {
        stage.addEventListener('stagemousemove', onStageMouseMove);
        stage.addEventListener('stagemouseup', onStageMouseUp);
        startP.setValues(e.stageX, e.stageY);
        shape = new createjs.Shape();
        stage.addChild(shape);
    }

    function onStageMouseMove(e) {
        endP.setValues(e.stageX, e.stageY);
        draw();
    }

    function onStageMouseUp(e) {
        stage.removeEventListener('stagemousemove', onStageMouseMove);
        stage.removeEventListener('stagemouseup', onStageMouseUp);

        endP.setValues(e.stageX, e.stageY);
        draw();

        if (startP.distance(endP) < 4) {
            stage.removeChild(shape);
        } else {
            shapes.set(shape, new _LineSegment.LineSegment(startP.x, startP.y, endP.x, endP.y));
            drawIntersection();
        }
        startP.setValues(0, 0);
        endP.setValues(0, 0);
    }

    /**
     * 绘制直线间的交点
     */
    function drawIntersection() {
        var intersections = [];
        var keys = [].concat(_toConsumableArray(shapes.keys()));
        for (var i = 0; i < keys.length; i++) {
            var l1 = shapes.get(keys[i]);
            for (var j = i + 1; j < keys.length; j++) {
                var l2 = shapes.get(keys[j]);
                var intersection = l1.getLineIntersection(l2);
                if (intersection !== null) {
                    var _data = new IntersectionAndAngle(intersection, l1.getIntersectionAngle(l2));
                    intersections.push(_data);
                }
            }
        }

        var g = intersectionShape.graphics;
        g.clear();
        g.setStrokeStyle(1);

        intersections.forEach(function (value) {
            var intersection = value.intersection;
            var angle = value.angle.toFixed(2);
            var txt = new createjs.Text(angle, '12px Arial', 'blue');
            g.beginStroke('red');
            g.drawCircle(intersection.x, intersection.y, 4);
            angleContainer.addChild(txt);
            txt.x = intersection.x;
            txt.y = intersection.y;

            g.endStroke();
        });
    }

    function draw() {
        var g = shape.graphics;

        g.clear();
        g.setStrokeStyle(1);
        g.beginStroke('black');

        switch (data.drawOption) {
            case 'line':
                {
                    var x = startP.x;
                    var y = startP.y;
                    var k = (endP.y - y) / (endP.x - x);
                    var b = y - x * k;
                    var MAX = 9999;

                    if (k === Infinity || k === -Infinity) {
                        g.moveTo(x, -MAX);
                        g.lineTo(x, MAX);
                    } else {
                        g.moveTo(-MAX, -MAX * k + b);
                        g.lineTo(MAX, MAX * k + b);
                    }
                }
                break;
            case 'lineSegment':
                {
                    var _x = startP.x;
                    var _y = startP.y;
                    shape.x = _x;
                    shape.y = _y;
                    g.moveTo(0, 0);
                    g.lineTo(endP.x - _x, endP.y - _y);
                }
                break;
            case 'ellipse':
                {
                    var w = endP.x - startP.x;
                    var h = endP.y - startP.y;
                    shape.x = startP.x;
                    shape.y = startP.y;
                    g.drawEllipse(0, 0, w, h);
                }
                break;
            case 'circle':
                {
                    var _w = endP.x - startP.x;
                    var _h = endP.y - startP.y;
                    var offsetX = _w / 2;
                    var offsetY = _h / 2;
                    var radius = Math.sqrt(Math.pow(_w, 2) + Math.pow(_h, 2)) / 2;
                    shape.x = startP.x + offsetX;
                    shape.y = startP.y + offsetY;
                    g.drawCircle(0, 0, radius);
                    break;
                }
            case 'rectangle':
                {
                    var _w2 = endP.x - startP.x;
                    var _h2 = endP.y - startP.y;
                    shape.x = startP.x;
                    shape.y = startP.y;
                    g.drawRect(0, 0, _w2, _h2);
                }
                break;

        }
    }
}
},{"../coniferCone/geom/LineSegment":3,"../coniferCone/geom/Point":4}]},{},[5])