(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Angle = function () {
    _createClass(Angle, null, [{
        key: "normal",

        /**
         * 限定角度范围在 0~360，弧度范围限定在0~2π
         * @param degree
         * @param isDegree
         * @returns {*}
         */
        value: function normal() {
            var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var isDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            //弧度
            if (isDegree) {
                while (degree >= 360) {
                    degree -= 360;
                }
                while (degree < 0) {
                    degree += 360;
                }
                return degree;
            }
            //角度
            else {
                    var angle = degree;
                    while (angle >= Angle.PI2) {
                        angle -= Angle.PI2;
                    }
                    while (angle < 0) {
                        angle += Angle.PI2;
                    }
                    return angle;
                }
        }

        /**
         * 初始化Angle，可以传入弧度或者角度
         * @param degree
         * @param isDegree  默认为true，表示第一个参数是弧度，设置为false，则表示第一个参数是角度
         *
         */

    }]);

    function Angle() {
        var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var isDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        _classCallCheck(this, Angle);

        if (isDegree) {
            this.degree = degree;
        } else {
            this.angle = degree;
        }
    }

    _createClass(Angle, [{
        key: "degree",
        set: function set(value) {
            this._degree = Angle.normal(value);
            this._angle = this._degree * Angle.DEGREE_TO_ANGLE;
        },
        get: function get() {
            return this._degree;
        }
    }, {
        key: "angle",
        set: function set(value) {
            this._degree = Angle.normal(value * Angle.ANGLE_TO_DEGREE);
            this._angle = this._degree * Angle.DEGREE_TO_ANGLE;
        },
        get: function get() {
            return this._angle;
        }

        /**
         * 是否锐角
         * @returns {boolean}
         */

    }, {
        key: "isAcute",
        get: function get() {
            return this._degree < 90 || this._degree > 270;
        }

        /**
         * 是否直角
         * @returns {boolean}
         */

    }, {
        key: "isRight",
        get: function get() {
            return this._degree === 90 || this._degree === 270;
        }

        /**
         * 是否钝角
         * @returns {boolean}
         */

    }, {
        key: "isObtuse",
        get: function get() {
            return this._degree > 90 && this._degree < 270;
        }

        /**
         * 求锐角
         * @returns {number}
         */

    }, {
        key: "acute",
        get: function get() {
            var a = this._degree;
            while (a > 90) {
                a -= 180;
            }

            while (a < -90) {
                a += 180;
            }
            return a >= 0 ? a : -a;
        }

        /**
         * 求钝角
         * @returns {number}
         */

    }, {
        key: "obtuse",
        get: function get() {
            return 180 - this.acute;
        }
    }]);

    return Angle;
}();

Angle.DEGREE_TO_ANGLE = Math.PI / 180;
Angle.ANGLE_TO_DEGREE = 180 / Math.PI;
Angle.PI2 = Math.PI * 2;

exports.Angle = Angle;
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Line = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by work on 2017/2/16.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Point = require("./Point");

var _Angle = require("./Angle");

var _Intersection = require("../util/Intersection");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Line = function () {
    function Line() {
        _classCallCheck(this, Line);

        //垂直于x轴
        if (arguments.length === 1) {
            this.x = arguments[0];
            this.k = Infinity;
        }
        //k,b
        else if (arguments.length === 2) {
                this.k = arguments[0];
                this.b = arguments[1];
            }
            //x1,y1,x2,y2
            else if (arguments.length === 4) {
                    var x1 = arguments[0];
                    var y1 = arguments[1];
                    var x2 = arguments[2];
                    var y2 = arguments[3];
                    this.k = (y2 - y1) / (x2 - x1);

                    if (this.isVertical) {
                        this.x = x1;
                    } else {
                        this.b = y1 - this.k * x1;
                    }
                } else {
                    throw new Error('arguments number invalid');
                }
        this.range = [-999999999, 999999999];
    }

    /**
     * 获取用于绘图的点
     * @returns {*}
     */


    _createClass(Line, [{
        key: "isPointInLine",


        /**
         * 是否点在直线上，支持传入Point作为参数以及x、y轴坐标作为参数
         *
         *  let p=new Point(1,2);
         *  isPointInLine(p)
         *  isPointInLine(1,2);
         *
         * @param x
         * @param y
         * @returns {boolean}
         */
        value: function isPointInLine(x, y) {
            if (arguments.length === 1 && x instanceof _Point.Point) {
                y = x.y;
                x = x.x;
            }
            if (this.isVertical) {
                return x === this.x;
            }
            return this.k * x + this.b === y;
        }

        /**
         * 获取和另外一条直线的交点
         * @param l
         */

    }, {
        key: "getLineIntersection",
        value: function getLineIntersection(l) {
            return _Intersection.Intersection.lineToLine(this, l);
        }

        /**
         * 获取经过指定点的垂线
         * @param x
         * @param y
         * @returns {Line}
         */

    }, {
        key: "getVerticalLine",
        value: function getVerticalLine(x, y) {
            if (this.isVertical) {
                return new Line(0, y);
            }
            if (this.isHorizontal) {
                return new Line(x);
            }
            return new Line(-1 / this.k, y + x / this.k);
        }

        /**
         * 获取经过指定点的垂线交点
         * @param x
         * @param y
         * @returns {*}
         */

    }, {
        key: "getVerticalIntersection",
        value: function getVerticalIntersection(x, y) {
            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);
            var verticalLine = this.getVerticalLine(x, y);
            return this.getLineIntersection(verticalLine);
        }

        /**
         * 获取对称点
         * @param x
         * @param y
         * @returns {Point}
         */

    }, {
        key: "getSymmetryPoint",
        value: function getSymmetryPoint(x, y) {

            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);

            //换算成一般式
            var A = this.k;
            var B = -1;
            var C = this.b;
            var temp = 2 * (A * x + B * y + C) / (A * A + B * B);

            return new _Point.Point(x - A * temp, y - B * temp);
        }

        /**
         * 获取两线夹角（0<=angle<=90）
         * @param l
         * @returns {number}
         */

    }, {
        key: "getIntersectionAngle",
        value: function getIntersectionAngle(l) {
            var angle = new _Angle.Angle();
            //平行
            if (this.k === l.k) {
                return 0;
            }
            //如果有一条直线垂直于x轴，计算出另外一条直线和x轴之间的夹角，然后用90度减去这个夹角
            if (this.isVertical || l.isVertical) {
                angle.angle = Math.atan(Math.abs(this.isVertical ? l.k : this.k));
                return 90 - angle.acute;
            }
            angle.angle = Math.atan(this.k) - Math.atan(l.k);
            return angle.acute;
        }
    }, {
        key: "points",
        get: function get() {
            var p = void 0;
            if (this.isVertical) {
                p = [new _Point.Point(this.x, this.range[0]), new _Point.Point(this.x, this.range[1])];
            } else if (this.isHorizontal) {
                p = [new _Point.Point(this.range[0], this.b), new _Point.Point(this.range[1], this.b)];
            } else {
                p = [new _Point.Point(this.range[0], this.k * this.range[0] + this.b), new _Point.Point(this.range[1], this.k * this.range[1] + this.b)];
            }
            return p;
        }

        /**
         * 垂直
         * @returns {boolean}
         */

    }, {
        key: "isVertical",
        get: function get() {
            return this.k === Infinity || this.k === -Infinity || this.b === Infinity || this.b === -Infinity;
        }

        /**
         * 水平
         * @returns {boolean}
         */

    }, {
        key: "isHorizontal",
        get: function get() {
            return this.k === 0;
        }
    }]);

    return Line;
}();

exports.Line = Line;
},{"../util/Intersection":7,"./Angle":1,"./Point":4}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineSegment = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Line2 = require("./Line");

var _Vector = require("./Vector");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by work on 2017/2/17.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var LineSegment = function (_Line) {
    _inherits(LineSegment, _Line);

    function LineSegment(x1, y1, x2, y2) {
        _classCallCheck(this, LineSegment);

        var k = Math.tan((y2 - y1) / (x2 - x1));
        var b = y1 - k * x1;

        var _this = _possibleConstructorReturn(this, (LineSegment.__proto__ || Object.getPrototypeOf(LineSegment)).call(this, k, b));

        _this.p1 = new _Vector.Vector(x1, y1);
        _this.p2 = new _Vector.Vector(x2, y2);
        _this.range = [Math.min(x1, x2), Math.max(x1, x2)];
        return _this;
    }

    _createClass(LineSegment, [{
        key: "getDistanceFromPoint",


        /**
         * 点到线段的距离
         * @param x
         * @param y
         */
        value: function getDistanceFromPoint(x, y) {}

        /**
         * 是否点在线段上
         * @param x
         * @param y
         */

    }, {
        key: "isPointInLineSegment",
        value: function isPointInLineSegment(x, y) {
            var p = new _Vector.Vector(x, y);
            var p_p1 = _Vector.Vector.subVectors(this.p1, p);
            var p_p2 = _Vector.Vector.subVectors(this.p2, p);

            return p_p1.angleTo(p_p2) === Math.PI;
        }

        /**
         * 线段到线段的距离
         * @param l
         */

    }, {
        key: "getDistanceFromLineSegment",
        value: function getDistanceFromLineSegment(l) {}
    }, {
        key: "toVector",
        value: function toVector() {
            return _Vector.Vector.subVectors(this.p2, this.p1);
        }
    }, {
        key: "length",
        get: function get() {
            return new _Vector.Vector().subVectors(this.p1, this.p2).length;
        }
    }]);

    return LineSegment;
}(_Line2.Line);

exports.LineSegment = LineSegment;
},{"./Line":2,"./Vector":5}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Point = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by work on 2017/2/21.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _Distance = require("../util/Distance");

var _Vector = require("./Vector");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Point = function () {
    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, Point);

        this.setValues(x, y);
    }

    _createClass(Point, [{
        key: "setValues",
        value: function setValues() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            this.x = x;
            this.y = y;
            return this;
        }
    }, {
        key: "copy",
        value: function copy(p) {
            this.x = p.x;
            this.y = p.y;
            return this;
        }

        /**
         * 两点间的直线距离
         * @param p
         * @returns {number}
         */

    }, {
        key: "distance",
        value: function distance(p) {
            return _Distance.Distance.pointToPoint(this, p);
        }

        /**
         * 返回该点的一个克隆
         * @method clone
         * @return {Point} 克隆之后的Point实例
         **/

    }, {
        key: "clone",
        value: function clone() {
            return new Point(this.x, this.y);
        }

        /**
         * Returns a string representation of this object.
         * @method toString
         * @return {String} a string representation of the instance.
         **/

    }, {
        key: "toString",
        value: function toString() {
            return "[Point (x=" + this.x + " y=" + this.y + ")]";
        }

        /**
         * 转换成Vector2
         * @returns {Vector}
         */

    }, {
        key: "toVector",
        value: function toVector() {
            return new _Vector.Vector(this.x, this.y);
        }
    }]);

    return Point;
}();

exports.Point = Point;
},{"../util/Distance":6,"./Vector":5}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * 基于threejs->Vector2，
 */

var Vector = function () {
    function Vector(x, y) {
        _classCallCheck(this, Vector);

        this.x = x || 0;
        this.y = y || 0;
    }

    _createClass(Vector, [{
        key: 'setValues',


        //为配合代码命名的规范，修改set为setValues
        value: function setValues(x, y) {
            this.x = x;
            this.y = y;

            return this;
        }
    }, {
        key: 'setScalar',
        value: function setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;

            return this;
        }
    }, {
        key: 'setX',
        value: function setX(x) {
            this.x = x;

            return this;
        }
    }, {
        key: 'setY',
        value: function setY(y) {
            this.y = y;

            return this;
        }

        /**
         * setComponent(0,value)表示设置x值
         * setComponent(1,value)表示设置y值
         * @param index
         * @param value
         * @returns {Vector}
         */

    }, {
        key: 'setComponent',
        value: function setComponent(index, value) {
            switch (index) {

                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);

            }
            return this;
        }
    }, {
        key: 'getComponent',
        value: function getComponent(index) {
            switch (index) {

                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);

            }
        }
    }, {
        key: 'clone',
        value: function clone() {
            return new this.constructor(this.x, this.y);
        }
    }, {
        key: 'copy',
        value: function copy(v) {
            this.x = v.x;
            this.y = v.y;

            return this;
        }

        /**
         * 参数为1个的时候表示一个vector2对象
         * 参数为2的时候，实际上执行的是addVectors方法
         * @param v
         * @param w
         * @returns {*}
         */

    }, {
        key: 'add',
        value: function add(v, w) {

            if (w !== undefined) {
                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }

            this.x += v.x;
            this.y += v.y;

            return this;
        }
    }, {
        key: 'addScalar',
        value: function addScalar(s) {

            this.x += s;
            this.y += s;

            return this;
        }

        /**
         * 两个矢量之和
         * @param a
         * @param b
         * @returns {Vector}
         */

    }, {
        key: 'addVectors',
        value: function addVectors(a, b) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;

            return this;
        }
    }, {
        key: 'addScaledVector',
        value: function addScaledVector(v, s) {

            this.x += v.x * s;
            this.y += v.y * s;

            return this;
        }
    }, {
        key: 'sub',
        value: function sub(v, w) {

            if (w !== undefined) {
                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }

            this.x -= v.x;
            this.y -= v.y;

            return this;
        }
    }, {
        key: 'subScalar',
        value: function subScalar(s) {

            this.x -= s;
            this.y -= s;

            return this;
        }
    }, {
        key: 'subVectors',
        value: function subVectors(a, b) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;

            return this;
        }
    }, {
        key: 'multiply',
        value: function multiply(v) {

            this.x *= v.x;
            this.y *= v.y;

            return this;
        }
    }, {
        key: 'multiplyScalar',
        value: function multiplyScalar(scalar) {

            if (isFinite(scalar)) {

                this.x *= scalar;
                this.y *= scalar;
            } else {

                this.x = 0;
                this.y = 0;
            }

            return this;
        }

        /**
         * 做除法，点乘的变种
         * @param v
         * @returns {Vector}
         */

    }, {
        key: 'divide',
        value: function divide(v) {

            this.x /= v.x;
            this.y /= v.y;

            return this;
        }
    }, {
        key: 'divideScalar',
        value: function divideScalar(scalar) {

            return this.multiplyScalar(1 / scalar);
        }
    }, {
        key: 'min',
        value: function min(v) {

            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);

            return this;
        }
    }, {
        key: 'max',
        value: function max(v) {

            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);

            return this;
        }
    }, {
        key: 'clamp',
        value: function clamp(min, max) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));

            return this;
        }

        /*clampScalar () {
          var min, max;
          return function clampScalar( minVal, maxVal ) {
          if ( min === undefined ) {
          min = new Vector2();
         max = new Vector2();
          }
          min.set( minVal, minVal );
         max.set( maxVal, maxVal );
          return this.clamp( min, max );
          };
          }();*/

    }, {
        key: 'clampLength',
        value: function clampLength(min, max) {

            var length = this.length();

            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        }
    }, {
        key: 'floor',
        value: function floor() {

            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);

            return this;
        }
    }, {
        key: 'ceil',
        value: function ceil() {

            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);

            return this;
        }
    }, {
        key: 'round',
        value: function round() {

            this.x = Math.round(this.x);
            this.y = Math.round(this.y);

            return this;
        }
    }, {
        key: 'roundToZero',
        value: function roundToZero() {

            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

            return this;
        }
    }, {
        key: 'negate',
        value: function negate() {

            this.x = -this.x;
            this.y = -this.y;

            return this;
        }

        /**
         * 点乘
         * @param v
         * @returns {number}
         */

    }, {
        key: 'dot',
        value: function dot(v) {
            return this.x * v.x + this.y * v.y;
        }

        /**
         * 叉乘方向，在为二维矢量中用来描述方向
         * 大于0，小于0，等于0（共线）
         * @param v
         * @returns {number}
         */

    }, {
        key: 'cross',
        value: function cross(v) {
            return this.x * v.y - this.y * v.x;
        }
    }, {
        key: 'lengthSq',
        value: function lengthSq() {

            return this.x * this.x + this.y * this.y;
        }
    }, {
        key: 'lengthManhattan',
        value: function lengthManhattan() {

            return Math.abs(this.x) + Math.abs(this.y);
        }
    }, {
        key: 'normalize',
        value: function normalize() {
            return this.divideScalar(this.length);
        }

        /**
         * 和另一个向量的夹角弧度值
         * @param v
         * @returns {number}
         */

    }, {
        key: 'angleTo',
        value: function angleTo(v) {
            var cos = this.dot(v) / (this.length * v.length);
            return Math.acos(cos); //0~π
        }
    }, {
        key: 'distanceTo',
        value: function distanceTo(v) {

            return Math.sqrt(this.distanceToSquared(v));
        }
    }, {
        key: 'distanceToSquared',
        value: function distanceToSquared(v) {

            var dx = this.x - v.x,
                dy = this.y - v.y;
            return dx * dx + dy * dy;
        }
    }, {
        key: 'distanceToManhattan',
        value: function distanceToManhattan(v) {

            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }

        /**
         * 定比分点
         *
         * @param v
         * @param alpha
         * @returns {Vector}
         */

    }, {
        key: 'lerp',
        value: function lerp(v, alpha) {

            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;

            return this;
        }
    }, {
        key: 'lerpVectors',
        value: function lerpVectors(v1, v2, alpha) {

            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        }
    }, {
        key: 'equals',
        value: function equals(v) {

            return v.x === this.x && v.y === this.y;
        }
    }, {
        key: 'fromArray',
        value: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.x = array[offset];
            this.y = array[offset + 1];

            return this;
        }
    }, {
        key: 'toArray',
        value: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.x;
            array[offset + 1] = this.y;

            return array;
        }
    }, {
        key: 'fromAttribute',
        value: function fromAttribute(attribute, index, offset) {

            if (offset === undefined) offset = 0;

            index = index * attribute.itemSize + offset;

            this.x = attribute.array[index];
            this.y = attribute.array[index + 1];

            return this;
        }

        /**
         * 旋转
         * @param center
         * @param angle
         * @returns {Vector}
         */

    }, {
        key: 'rotateAround',
        value: function rotateAround(center, angle) {

            var c = Math.cos(angle),
                s = Math.sin(angle);

            var x = this.x - center.x;
            var y = this.y - center.y;

            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;

            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return "[Vector2 (x=" + this.x + " y=" + this.y + ")]";
        }
    }, {
        key: 'width',
        get: function get() {
            return this.x;
        },
        set: function set(value) {
            this.x = value;
        }
    }, {
        key: 'height',
        get: function get() {
            return this.y;
        },
        set: function set(value) {
            this.y = value;
        }
    }, {
        key: 'length',
        get: function get() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        set: function set(length) {

            return this.multiplyScalar(length / this.length);
        }
    }, {
        key: 'angle',
        get: function get() {

            // computes the angle in radians with respect to the positive x-axis

            var angle = Math.atan2(this.y, this.x); //-π~π

            if (angle < 0) angle += 2 * Math.PI; //0~2π

            return angle;
        }
    }], [{
        key: 'addVectors',
        value: function addVectors(a, b) {
            return new Vector().addVectors(a, b);
        }
    }, {
        key: 'subVectors',
        value: function subVectors(a, b) {
            return new Vector().subVectors(a, b);
        }
    }, {
        key: 'lerpVectors',
        value: function lerpVectors(v1, v2, alpha) {
            return new Vector().lerpVectors(v1, v2, alpha);
        }
    }]);

    return Vector;
}();

exports.Vector = Vector;
},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by work on 2017/2/23.
 */
var Distance = function () {
    function Distance() {
        _classCallCheck(this, Distance);

        throw new Error('Instantiation is not allowed!');
    }

    /**
     * 两点之间的距离
     * @param p1
     * @param p2
     * @returns {number}
     */


    _createClass(Distance, null, [{
        key: 'pointToPoint',
        value: function pointToPoint(p1, p2) {
            var w = p1.x - p2.x;
            var h = p1.y - p2.y;
            return Math.sqrt(w * w + h * h);
        }
    }, {
        key: 'lineSegmentToLineSegment',

        /**
         * 两条线段之间的距离
         * @param ls1
         * @param ls2
         * @returns {number}
         * @constructor
         */
        value: function lineSegmentToLineSegment(ls1, ls2) {

            return 0;
        }
    }, {
        key: 'pointToLineSegment',

        /**
         * 点到线段的距离
         * @param p
         * @param ls
         * @returns {number}
         */
        value: function pointToLineSegment(p, ls) {
            //点是否在线段上
            if (ls.isPointInLineSegment) {
                return 0;
            } else {
                //根据r值来判断P点在AB上的投影是否在线段上
                var AB = ls.toVector();
                var AP = p.toVector().sub(ls.p1);
                var len = ls.length;
                var r = AP.dot(AB) / (len * len);
                if (r >= 1) {
                    return Distance.pointToPoint(p, ls.p2);
                } else if (r <= 0) {
                    return Distance.pointToPoint(p, ls.p1);
                } else {
                    var intersection = ls.p1.toVector().lerp(ls.p2.toVector(), r);
                    return Distance.pointToPoint(p, intersection);
                }
            }
        }
    }, {
        key: 'pointToCircle',

        /**
         * 点到圆的距离
         * @param p
         * @param c
         * @returns {number}
         */
        value: function pointToCircle(p, c) {
            return 0;
        }
    }]);

    return Distance;
}();

exports.Distance = Distance;
},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Intersection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Point = require("../geom/Point");

var _Vector = require("../geom/Vector");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Intersection = function () {
    function Intersection() {
        _classCallCheck(this, Intersection);

        throw new Error('Instantiation is not allowed!');
    }

    /**
     * 两条直线之间的交点
     * @param l1
     * @param l2
     * @returns {*}
     */


    _createClass(Intersection, null, [{
        key: "lineToLine",
        value: function lineToLine(l1, l2) {
            //平行
            if (l1.k === l2.k) {
                return null;
            }
            //两条线中有一条垂直
            else if (l1.isVertical || l2.isVertical) {
                    return new _Point.Point(l1.isVertical ? l1.x : l2.x, l1.isVertical ? l2.k * l1.x + l2.b : l1.k * l2.x + l1.b);
                } else {
                    var k1 = l1.k;
                    var b1 = l1.b;
                    var k2 = l2.k;
                    var b2 = l2.b;
                    var x = (b2 - b1) / (k1 - k2);
                    return new _Point.Point(x, k1 * x + b1);
                }
        }

        /**
         * 两条线段的交点
         * @param ls1
         * @param ls2
         * @returns {Point}
         */

    }, {
        key: "lineSegmentToLineSegment",
        value: function lineSegmentToLineSegment(ls1, ls2) {
            //AB为线段ls1的两个端点，CD为线段ls2的两个端点
            var A = ls1.p1;
            var B = ls1.p2;
            var C = ls2.p1;
            var D = ls2.p2;

            var AB = _Vector.Vector.subVectors(B, A);
            var AC = _Vector.Vector.subVectors(C, A);
            var AD = _Vector.Vector.subVectors(D, A);
            var CD = _Vector.Vector.subVectors(D, C);
            var CA = _Vector.Vector.subVectors(A, C);
            var CB = _Vector.Vector.subVectors(B, C);

            var ABXAC = AB.cross(AC);
            var ABXAD = AB.cross(AD);
            var CDXCA = CD.cross(CA);
            var CDXCB = CD.cross(CB);

            //有叉乘值为0的项，则表示有有一点在另外一条线段上
            if (ABXAC === 0 || ABXAD === 0 || CDXCA === 0 || CDXCB === 0) {
                //todo:暂不处理有一点在另外一条线段上的情况
                return null;
            } else {
                //ABXAC和ABXAD方向相反，并且CDXCA和CDXCB方向相反则必定相交
                if ((ABXAC ^ ABXAD) < 0 && (CDXCA ^ CDXCB) < 0) {
                    var n = Math.abs(ABXAC / ABXAD);
                    return _Vector.Vector.lerpVectors(C, D, n / (1 + n));
                } else {
                    return null;
                }
            }
        }
    }]);

    return Intersection;
}();

exports.Intersection = Intersection;
},{"../geom/Point":4,"../geom/Vector":5}],8:[function(require,module,exports){
"use strict";

var _UI_LineSegment = require("./ui/UI_LineSegment");

var _UI_Point = require("./ui/UI_Point");

var _Vector = require("../coniferCone/geom/Vector");

var _LineSegment = require("../coniferCone/geom/LineSegment");

var _Intersection = require("../coniferCone/util/Intersection");

var app = new Vue({
    el: "#app",
    data: {
        p: new _Vector.Vector(100, 100),
        p1: new _Vector.Vector(200, 150),
        p2: new _Vector.Vector(300, 100),
        p3: new _Vector.Vector(300, 100),
        p4: new _Vector.Vector(300, 200)

    }
}); /**
     * Created by work on 2017/3/1.
     */

var stage = new createjs.Stage(document.getElementsByTagName('canvas')[0]);
createjs.Ticker.setFPS(60);
createjs.Ticker.addEventListener('tick', stage);

var edgeA = new _UI_LineSegment.UI_LineSegment(app.p1, app.p2);
var edgeB = new _UI_LineSegment.UI_LineSegment(app.p3, app.p4);
var dot = new _UI_Point.UI_Point(app.p);

var intersectionShape = new createjs.Shape();

stage.addChild(edgeA);
stage.addChild(edgeB);
stage.addChild(dot);
stage.addChild(intersectionShape);

var nextTick = false;
function changeAngle() {
    if (!nextTick) {
        app.$nextTick(function () {

            var lsA = new _LineSegment.LineSegment(app.p1.x, app.p1.y, app.p2.x, app.p2.y);
            var lsB = new _LineSegment.LineSegment(app.p3.x, app.p3.y, app.p4.x, app.p4.y);
            var intersection = _Intersection.Intersection.lineSegmentToLineSegment(lsA, lsB);
            var g = intersectionShape.graphics;
            g.clear();
            if (intersection) {
                g.setStrokeStyle(1);
                g.beginStroke('black');
                g.drawCircle(intersection.x, intersection.y, 4);
            } else {}
            nextTick = false;
        });
        nextTick = true;
    }
}

app.$watch('p1.x', changeAngle);
app.$watch('p1.y', changeAngle);
app.$watch('p2.x', changeAngle);
app.$watch('p2.y', changeAngle);
app.$watch('p3.x', changeAngle);
app.$watch('p3.y', changeAngle);
app.$watch('p4.x', changeAngle);
app.$watch('p4.y', changeAngle);
},{"../coniferCone/geom/LineSegment":3,"../coniferCone/geom/Vector":5,"../coniferCone/util/Intersection":7,"./ui/UI_LineSegment":10,"./ui/UI_Point":11}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DragManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require('../../coniferCone/geom/Vector');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DragManager = function () {
    function DragManager(stage) {
        _classCallCheck(this, DragManager);

        this.stage = stage;
        this.currentObject = null;
        this.moveEventID = new Map();
        this.originalP = new Map();
        this.objs = new Set();
    }

    _createClass(DragManager, [{
        key: 'register',
        value: function register(displayObject) {
            this.objs.add(displayObject);
            displayObject.on('mousedown', this.onMouseDown, this);
        }
    }, {
        key: 'unregister',
        value: function unregister(displayObject) {
            displayObject.removeAllEventListeners();
            this.objs.delete(displayObject);
        }
    }, {
        key: 'onMouseDown',
        value: function onMouseDown(e) {
            this.currentObjet = e.target;

            var p = this.currentObjet.localToGlobal(0, 0);
            this.originalP.set(this.currentObjet, new _Vector.Vector(p.x, p.y));

            var moveEventID = this.stage.on('stagemousemove', this.onMouseMove, this);
            this.moveEventID.set(this.currentObjet, moveEventID);

            this.stage.on('stagemouseup', this.onMouseUp, this, true);

            if (Reflect.get(this.currentObjet, 'onStartDrag')) {
                this.currentObjet.onStartDrag();
            } else {
                this.defaultDownHandle();
            }
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            var originalP = this.originalP.get(this.currentObjet);
            var moveP = new _Vector.Vector(e.stageX, e.stageY);
            var offsetP = _Vector.Vector.subVectors(moveP, originalP);

            if (Reflect.get(this.currentObjet, 'onDraging')) {
                this.currentObjet.onDraging(originalP, offsetP);
            } else {
                this.defaultMoveHandle(originalP, offsetP);
            }
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(e) {
            this.stage.off('stagemousemove', this.moveEventID.get(this.currentObjet));
            this.moveEventID.delete(this.currentObjet);

            var originalP = this.originalP.get(this.currentObjet);
            var moveP = new _Vector.Vector(e.stageX, e.stageY);
            var offsetP = _Vector.Vector.subVectors(moveP, originalP);

            if (Reflect.get(this.currentObjet, 'onEndDrag')) {
                this.currentObjet.onEndDrag(originalP, offsetP);
            } else {
                this.defaultUpHandle(originalP, offsetP);
            }
        }
    }, {
        key: 'defaultMoveHandle',
        value: function defaultMoveHandle(originalP, offsetP) {
            var p = _Vector.Vector.addVectors(originalP, offsetP);
            this.currentObjet.x = p.x;
            this.currentObjet.y = p.y;
        }
    }, {
        key: 'defaultUpHandle',
        value: function defaultUpHandle(originalP, offsetP) {
            var p = _Vector.Vector.addVectors(originalP, offsetP);
            this.currentObjet.x = p.x;
            this.currentObjet.y = p.y;
        }
    }, {
        key: 'defaultDownHandle',
        value: function defaultDownHandle() {}
    }]);

    return DragManager;
}();

exports.DragManager = DragManager;
},{"../../coniferCone/geom/Vector":5}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UI_LineSegment = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _UI_Point = require("./UI_Point");

var _Vector = require("../../coniferCone/geom/Vector");

var _DragManager = require("../manager/DragManager");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UI_LineSegment = function (_createjs$Container) {
    _inherits(UI_LineSegment, _createjs$Container);

    /**
     *
     * @param p1   边的一个顶点
     * @param p2   边的另外一个顶点
     */
    function UI_LineSegment(p1, p2) {
        _classCallCheck(this, UI_LineSegment);

        var _this = _possibleConstructorReturn(this, (UI_LineSegment.__proto__ || Object.getPrototypeOf(UI_LineSegment)).call(this));

        _this.p1 = p1;
        _this.p2 = p2;
        _this.length = _Vector.Vector.subVectors(p2, p1).length;
        _this.dragManager = null;

        _this.dotA = new _UI_Point.UI_Point(new _Vector.Vector(0, 0));
        _this.dotB = new _UI_Point.UI_Point(new _Vector.Vector(0, 0));
        _this.line = new createjs.Shape();
        _this.dotC = new _UI_Point.UI_Point(new _Vector.Vector(0, 0), 4);

        _this.addChild(_this.line);
        _this.addChild(_this.dotA);
        _this.addChild(_this.dotB);
        _this.addChild(_this.dotC);

        _this.setPosition();
        _this.drawLine();

        _this.on('added', _this.onAdded, _this);

        return _this;
    }

    _createClass(UI_LineSegment, [{
        key: "setPosition",
        value: function setPosition() {
            var center = _Vector.Vector.lerpVectors(this.p2, this.p1, 0.5);

            this.x = center.x;
            this.y = center.y;
            this.dotA.setPosition(_Vector.Vector.subVectors(this.p1, center));
            this.dotB.setPosition(_Vector.Vector.subVectors(this.p2, center));
            this.dotC.setPosition(new _Vector.Vector());
        }
    }, {
        key: "drawLine",
        value: function drawLine() {
            var g = this.line.graphics;
            g.clear();
            g.setStrokeStyle(1);
            g.beginStroke(createjs.Graphics.getRGB(0, 0, 0));
            g.moveTo(0, 0);
            g.lineTo(this.dotA.x, this.dotA.y);
            g.moveTo(0, 0);
            g.lineTo(this.dotB.x, this.dotB.y);
        }
    }, {
        key: "onAdded",
        value: function onAdded() {
            if (this.dragManager === null) {
                this.dragManager = new _DragManager.DragManager(this.stage);
                this.dragManager.register(this.dotA);
                this.dragManager.register(this.dotB);
                this.dragManager.register(this.dotC);
                this.dotA.onDraging = function (originalP, offsetP) {
                    this.p1 = _Vector.Vector.addVectors(originalP, offsetP);

                    this.setPosition();
                    this.drawLine();
                };
            }
        }
    }]);

    return UI_LineSegment;
}(createjs.Container);

exports.UI_LineSegment = UI_LineSegment;
},{"../../coniferCone/geom/Vector":5,"../manager/DragManager":9,"./UI_Point":11}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UI_Point = function (_createjs$Shape) {
    _inherits(UI_Point, _createjs$Shape);

    /**
     *
     * @param p
     * @param radius
     * @param color
     */
    function UI_Point(p) {
        var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
        var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#09f';

        _classCallCheck(this, UI_Point);

        var _this = _possibleConstructorReturn(this, (UI_Point.__proto__ || Object.getPrototypeOf(UI_Point)).call(this));

        _this.p = p;

        var g = _this.graphics;
        g.setStrokeStyle(1);
        g.beginStroke('#000');
        g.beginFill(color);
        g.drawCircle(0, 0, radius);

        return _this;
    }

    _createClass(UI_Point, [{
        key: 'setPosition',
        value: function setPosition(p) {
            this.p = p;
            this.x = p.x;
            this.y = p.y;
        }
    }]);

    return UI_Point;
}(createjs.Shape);

exports.UI_Point = UI_Point;
},{}]},{},[8])