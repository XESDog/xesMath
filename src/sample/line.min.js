(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Angle = function () {
    _createClass(Angle, null, [{
        key: "normal",

        /**
         * 限定角度范围在 0~360，弧度范围限定在0~2π
         * @param degree
         * @param isDegree
         * @returns {*}
         */
        value: function normal() {
            var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var isDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            //弧度
            if (isDegree) {
                while (degree >= 360) {
                    degree -= 360;
                }
                while (degree < 0) {
                    degree += 360;
                }
                return degree;
            }
            //角度
            else {
                    var angle = degree;
                    while (angle >= Angle.PI2) {
                        angle -= Angle.PI2;
                    }
                    while (angle < 0) {
                        angle += Angle.PI2;
                    }
                    return angle;
                }
        }

        /**
         * 初始化Angle，可以传入弧度或者角度
         * @param degree
         * @param isDegree  默认为true，表示第一个参数是弧度，设置为false，则表示第一个参数是角度
         *
         */

    }]);

    function Angle() {
        var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var isDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        _classCallCheck(this, Angle);

        if (isDegree) {
            this.degree = degree;
        } else {
            this.angle = degree;
        }
    }

    _createClass(Angle, [{
        key: "degree",
        set: function set(value) {
            this._degree = Angle.normal(value);
            this._angle = this._degree * Angle.DEGREE_TO_ANGLE;
        },
        get: function get() {
            return this._degree;
        }
    }, {
        key: "angle",
        set: function set(value) {
            this._degree = Angle.normal(value * Angle.ANGLE_TO_DEGREE);
            this._angle = this._degree * Angle.DEGREE_TO_ANGLE;
        },
        get: function get() {
            return this._angle;
        }

        /**
         * 是否锐角
         * @returns {boolean}
         */

    }, {
        key: "isAcute",
        get: function get() {
            return this._degree < 90 || this._degree > 270;
        }

        /**
         * 是否直角
         * @returns {boolean}
         */

    }, {
        key: "isRight",
        get: function get() {
            return this._degree === 90 || this._degree === 270;
        }

        /**
         * 是否钝角
         * @returns {boolean}
         */

    }, {
        key: "isObtuse",
        get: function get() {
            return this._degree > 90 && this._degree < 270;
        }

        /**
         * 求锐角
         * @returns {number}
         */

    }, {
        key: "acute",
        get: function get() {
            var a = this._degree;
            while (a > 90) {
                a -= 180;
            }

            while (a < -90) {
                a += 180;
            }
            return a >= 0 ? a : -a;
        }

        /**
         * 求钝角
         * @returns {number}
         */

    }, {
        key: "obtuse",
        get: function get() {
            return 180 - this.acute;
        }
    }]);

    return Angle;
}();

Angle.DEGREE_TO_ANGLE = Math.PI / 180;
Angle.ANGLE_TO_DEGREE = 180 / Math.PI;
Angle.PI2 = Math.PI * 2;

exports.Angle = Angle;
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Line = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by work on 2017/2/16.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Point = require("./Point");

var _Angle = require("./Angle");

var _Intersection = require("../util/Intersection");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Line = function () {
    function Line() {
        _classCallCheck(this, Line);

        //垂直于x轴
        if (arguments.length === 1) {
            this.x = arguments[0];
            this.k = Infinity;
        }
        //k,b
        else if (arguments.length === 2) {
                this.k = arguments[0];
                this.b = arguments[1];
            }
            //x1,y1,x2,y2
            else if (arguments.length === 4) {
                    var x1 = arguments[0];
                    var y1 = arguments[1];
                    var x2 = arguments[2];
                    var y2 = arguments[3];
                    this.k = (y2 - y1) / (x2 - x1);

                    if (this.isVertical) {
                        this.x = x1;
                    } else {
                        this.b = y1 - this.k * x1;
                    }
                } else {
                    throw new Error('arguments number invalid');
                }
        this.range = [-999999999, 999999999];
    }

    /**
     * 获取用于绘图的点
     * @returns {*}
     */


    _createClass(Line, [{
        key: "isPointInLine",


        /**
         * 是否点在直线上，支持传入Point作为参数以及x、y轴坐标作为参数
         *
         *  let p=new Point(1,2);
         *  isPointInLine(p)
         *  isPointInLine(1,2);
         *
         * @param x
         * @param y
         * @returns {boolean}
         */
        value: function isPointInLine(x, y) {
            if (arguments.length === 1 && x instanceof _Point.Point) {
                y = x.y;
                x = x.x;
            }
            if (this.isVertical) {
                return x === this.x;
            }
            return this.k * x + this.b === y;
        }

        /**
         * 获取和另外一条直线的交点
         * @param l
         */

    }, {
        key: "getLineIntersection",
        value: function getLineIntersection(l) {
            return _Intersection.Intersection.lineToLine(this, l);
        }

        /**
         * 获取经过指定点的垂线
         * @param x
         * @param y
         * @returns {Line}
         */

    }, {
        key: "getVerticalLine",
        value: function getVerticalLine(x, y) {
            if (this.isVertical) {
                return new Line(0, y);
            }
            if (this.isHorizontal) {
                return new Line(x);
            }
            return new Line(-1 / this.k, y + x / this.k);
        }

        /**
         * 获取经过指定点的垂线交点
         * @param x
         * @param y
         * @returns {*}
         */

    }, {
        key: "getVerticalIntersection",
        value: function getVerticalIntersection(x, y) {
            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);
            var verticalLine = this.getVerticalLine(x, y);
            return this.getLineIntersection(verticalLine);
        }

        /**
         * 获取对称点
         * @param x
         * @param y
         * @returns {Point}
         */

    }, {
        key: "getSymmetryPoint",
        value: function getSymmetryPoint(x, y) {

            if (this.isPointInLine(x, y)) return new _Point.Point(x, y);

            //换算成一般式
            var A = this.k;
            var B = -1;
            var C = this.b;
            var temp = 2 * (A * x + B * y + C) / (A * A + B * B);

            return new _Point.Point(x - A * temp, y - B * temp);
        }

        /**
         * 获取两线夹角（0<=angle<=90）
         * @param l
         * @returns {number}
         */

    }, {
        key: "getIntersectionAngle",
        value: function getIntersectionAngle(l) {
            var angle = new _Angle.Angle();
            //平行
            if (this.k === l.k) {
                return 0;
            }
            //如果有一条直线垂直于x轴，计算出另外一条直线和x轴之间的夹角，然后用90度减去这个夹角
            if (this.isVertical || l.isVertical) {
                angle.angle = Math.atan(Math.abs(this.isVertical ? l.k : this.k));
                return 90 - angle.acute;
            }
            angle.angle = Math.atan(this.k) - Math.atan(l.k);
            return angle.acute;
        }
    }, {
        key: "points",
        get: function get() {
            var p = void 0;
            if (this.isVertical) {
                p = [new _Point.Point(this.x, this.range[0]), new _Point.Point(this.x, this.range[1])];
            } else if (this.isHorizontal) {
                p = [new _Point.Point(this.range[0], this.b), new _Point.Point(this.range[1], this.b)];
            } else {
                p = [new _Point.Point(this.range[0], this.k * this.range[0] + this.b), new _Point.Point(this.range[1], this.k * this.range[1] + this.b)];
            }
            return p;
        }

        /**
         * 垂直
         * @returns {boolean}
         */

    }, {
        key: "isVertical",
        get: function get() {
            return this.k === Infinity || this.k === -Infinity || this.b === Infinity || this.b === -Infinity;
        }

        /**
         * 水平
         * @returns {boolean}
         */

    }, {
        key: "isHorizontal",
        get: function get() {
            return this.k === 0;
        }
    }]);

    return Line;
}();

exports.Line = Line;
},{"../util/Intersection":7,"./Angle":1,"./Point":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Point = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by work on 2017/2/21.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _Distance = require("../util/Distance");

var _Vector = require("./Vector2");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Point = function () {
    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, Point);

        this.setValues(x, y);
    }

    _createClass(Point, [{
        key: "setValues",
        value: function setValues() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            this.x = x;
            this.y = y;
            return this;
        }
    }, {
        key: "copy",
        value: function copy(p) {
            this.x = p.x;
            this.y = p.y;
            return this;
        }

        /**
         * 两点间的直线距离
         * @param p
         * @returns {number}
         */

    }, {
        key: "distance",
        value: function distance(p) {
            return _Distance.Distance.pointToPoint(this, p);
        }

        /**
         * 返回该点的一个克隆
         * @method clone
         * @return {Point} 克隆之后的Point实例
         **/

    }, {
        key: "clone",
        value: function clone() {
            return new Point(this.x, this.y);
        }

        /**
         * Returns a string representation of this object.
         * @method toString
         * @return {String} a string representation of the instance.
         **/

    }, {
        key: "toString",
        value: function toString() {
            return "[Point (x=" + this.x + " y=" + this.y + ")]";
        }

        /**
         * 转换成Vector2
         * @returns {Vector2}
         */

    }, {
        key: "toVector2",
        value: function toVector2() {
            return new _Vector.Vector2(this.x, this.y);
        }
    }]);

    return Point;
}();

exports.Point = Point;
},{"../util/Distance":6,"./Vector2":5}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Triangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Point = require("./Point");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Triangle = function () {
    function Triangle(x1, y1, x2, y2, x3, y3) {
        _classCallCheck(this, Triangle);

        //A
        this.p1 = new _Point.Point(x1, y1);
        //B
        this.p2 = new _Point.Point(x2, y2);
        //C
        this.p3 = new _Point.Point(x3, y3);
    }

    /**
     * 面积，矢量ABXAC再除以2
     * @returns {number}
     */


    _createClass(Triangle, [{
        key: "area",
        get: function get() {
            var AB = new Vector2().sub(this.p2, this.p1);
            var AC = new Vector2().sub(this.p3, this.p1);
            return Math.abs(AB.crossValue(AC)) * 0.5;
        }
    }]);

    return Triangle;
}();

exports.Triangle = Triangle;
},{"./Point":3}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * 基于threejs->Vector2
 */

var Vector2 = function () {
    function Vector2(x, y) {
        _classCallCheck(this, Vector2);

        this.x = x || 0;
        this.y = y || 0;
        this.isVector2 = true;
    }

    _createClass(Vector2, [{
        key: 'setValues',


        //为配合代码命名的规范，修改set为setValues
        value: function setValues(x, y) {
            this.x = x;
            this.y = y;

            return this;
        }
    }, {
        key: 'setScalar',
        value: function setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;

            return this;
        }
    }, {
        key: 'setX',
        value: function setX(x) {
            this.x = x;

            return this;
        }
    }, {
        key: 'setY',
        value: function setY(y) {
            this.y = y;

            return this;
        }

        /**
         * setComponent(0,value)表示设置x值
         * setComponent(1,value)表示设置y值
         * @param index
         * @param value
         * @returns {Vector2}
         */

    }, {
        key: 'setComponent',
        value: function setComponent(index, value) {
            switch (index) {

                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);

            }
            return this;
        }
    }, {
        key: 'getComponent',
        value: function getComponent(index) {
            switch (index) {

                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);

            }
        }
    }, {
        key: 'clone',
        value: function clone() {
            return new this.constructor(this.x, this.y);
        }
    }, {
        key: 'copy',
        value: function copy(v) {
            this.x = v.x;
            this.y = v.y;

            return this;
        }

        /**
         * 参数为1个的时候表示一个vector2对象
         * 参数为2的时候，实际上执行的是addVectors方法
         * @param v
         * @param w
         * @returns {*}
         */

    }, {
        key: 'add',
        value: function add(v, w) {

            if (w !== undefined) {
                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }

            this.x += v.x;
            this.y += v.y;

            return this;
        }
    }, {
        key: 'addScalar',
        value: function addScalar(s) {

            this.x += s;
            this.y += s;

            return this;
        }

        /**
         * 两个矢量之和
         * @param a
         * @param b
         * @returns {Vector2}
         */

    }, {
        key: 'addVectors',
        value: function addVectors(a, b) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;

            return this;
        }
    }, {
        key: 'addScaledVector',
        value: function addScaledVector(v, s) {

            this.x += v.x * s;
            this.y += v.y * s;

            return this;
        }
    }, {
        key: 'sub',
        value: function sub(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }

            this.x -= v.x;
            this.y -= v.y;

            return this;
        }
    }, {
        key: 'subScalar',
        value: function subScalar(s) {

            this.x -= s;
            this.y -= s;

            return this;
        }
    }, {
        key: 'subVectors',
        value: function subVectors(a, b) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;

            return this;
        }
    }, {
        key: 'multiply',
        value: function multiply(v) {

            this.x *= v.x;
            this.y *= v.y;

            return this;
        }
    }, {
        key: 'multiplyScalar',
        value: function multiplyScalar(scalar) {

            if (isFinite(scalar)) {

                this.x *= scalar;
                this.y *= scalar;
            } else {

                this.x = 0;
                this.y = 0;
            }

            return this;
        }

        /**
         * 做除法，点乘的变种
         * @param v
         * @returns {Vector2}
         */

    }, {
        key: 'divide',
        value: function divide(v) {

            this.x /= v.x;
            this.y /= v.y;

            return this;
        }
    }, {
        key: 'divideScalar',
        value: function divideScalar(scalar) {

            return this.multiplyScalar(1 / scalar);
        }
    }, {
        key: 'min',
        value: function min(v) {

            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);

            return this;
        }
    }, {
        key: 'max',
        value: function max(v) {

            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);

            return this;
        }
    }, {
        key: 'clamp',
        value: function clamp(min, max) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));

            return this;
        }

        /*clampScalar () {
          var min, max;
          return function clampScalar( minVal, maxVal ) {
          if ( min === undefined ) {
          min = new Vector2();
         max = new Vector2();
          }
          min.set( minVal, minVal );
         max.set( maxVal, maxVal );
          return this.clamp( min, max );
          };
          }();*/

    }, {
        key: 'clampLength',
        value: function clampLength(min, max) {

            var length = this.length();

            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        }
    }, {
        key: 'floor',
        value: function floor() {

            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);

            return this;
        }
    }, {
        key: 'ceil',
        value: function ceil() {

            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);

            return this;
        }
    }, {
        key: 'round',
        value: function round() {

            this.x = Math.round(this.x);
            this.y = Math.round(this.y);

            return this;
        }
    }, {
        key: 'roundToZero',
        value: function roundToZero() {

            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

            return this;
        }
    }, {
        key: 'negate',
        value: function negate() {

            this.x = -this.x;
            this.y = -this.y;

            return this;
        }

        /**
         * 点乘
         * @param v
         * @returns {number}
         */

    }, {
        key: 'dot',
        value: function dot(v) {
            return this.x * v.x + this.y * v.y;
        }

        /**
         * 叉乘所得值，不考虑方向
         * @param v
         */

    }, {
        key: 'crossValue',
        value: function crossValue(v) {
            var sin = Math.sin(this.radianTo(v));
            return this.length * v.length * sin;
        }
    }, {
        key: 'lengthSq',
        value: function lengthSq() {

            return this.x * this.x + this.y * this.y;
        }
    }, {
        key: 'lengthManhattan',
        value: function lengthManhattan() {

            return Math.abs(this.x) + Math.abs(this.y);
        }
    }, {
        key: 'normalize',
        value: function normalize() {
            return this.divideScalar(this.length);
        }

        /**
         * 和另一个向量的夹角弧度值
         * @param v
         * @returns {number}
         */

    }, {
        key: 'angleTo',
        value: function angleTo(v) {
            var cos = this.dot(v) / (this.length * v.length);
            return Math.acos(cos); //0~π
        }
    }, {
        key: 'distanceTo',
        value: function distanceTo(v) {

            return Math.sqrt(this.distanceToSquared(v));
        }
    }, {
        key: 'distanceToSquared',
        value: function distanceToSquared(v) {

            var dx = this.x - v.x,
                dy = this.y - v.y;
            return dx * dx + dy * dy;
        }
    }, {
        key: 'distanceToManhattan',
        value: function distanceToManhattan(v) {

            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }

        /**
         * 英文译为'线性插值'
         * 表示，在当前向量之后追加一个指向向量v的偏移量，该偏移量为this->v向量的alpha倍
         *
         * @param v
         * @param alpha
         * @returns {Vector2}
         */

    }, {
        key: 'lerp',
        value: function lerp(v, alpha) {

            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;

            return this;
        }

        /**
         * 往v1方向上追加一个v2方向上的偏移量，该偏移量为v1->v2向量的alpha倍
         * @param v1
         * @param v2
         * @param alpha
         * @returns {Vector2}
         */

    }, {
        key: 'lerpVectors',
        value: function lerpVectors(v1, v2, alpha) {

            return World.add(v1);
        }
    }, {
        key: 'equals',
        value: function equals(v) {

            return v.x === this.x && v.y === this.y;
        }
    }, {
        key: 'fromArray',
        value: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.x = array[offset];
            this.y = array[offset + 1];

            return this;
        }
    }, {
        key: 'toArray',
        value: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.x;
            array[offset + 1] = this.y;

            return array;
        }
    }, {
        key: 'fromAttribute',
        value: function fromAttribute(attribute, index, offset) {

            if (offset === undefined) offset = 0;

            index = index * attribute.itemSize + offset;

            this.x = attribute.array[index];
            this.y = attribute.array[index + 1];

            return this;
        }

        /**
         * 旋转
         * @param center
         * @param angle
         * @returns {Vector2}
         */

    }, {
        key: 'rotateAround',
        value: function rotateAround(center, angle) {

            var c = Math.cos(angle),
                s = Math.sin(angle);

            var x = this.x - center.x;
            var y = this.y - center.y;

            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;

            return this;
        }
    }, {
        key: 'width',
        get: function get() {
            return this.x;
        },
        set: function set(value) {
            this.x = value;
        }
    }, {
        key: 'height',
        get: function get() {
            return this.y;
        },
        set: function set(value) {
            this.y = value;
        }
    }, {
        key: 'length',
        get: function get() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        set: function set(length) {

            return this.multiplyScalar(length / this.length);
        }
    }, {
        key: 'angle',
        get: function get() {

            // computes the angle in radians with respect to the positive x-axis

            var angle = Math.atan2(this.y, this.x); //-π~π

            if (angle < 0) angle += 2 * Math.PI; //0~2π

            return angle;
        }
    }]);

    return Vector2;
}();

exports.Vector2 = Vector2;
},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by work on 2017/2/23.
 */
var Distance = function () {
    function Distance() {
        _classCallCheck(this, Distance);

        throw new Error('Instantiation is not allowed!');
    }

    /**
     * 两点之间的距离
     * @param p1
     * @param p2
     * @returns {number}
     */


    _createClass(Distance, null, [{
        key: 'pointToPoint',
        value: function pointToPoint(p1, p2) {
            var w = p1.x - p2.x;
            var h = p1.y - p2.y;
            return Math.sqrt(w * w + h * h);
        }
    }, {
        key: 'lineSegmentToLineSegment',

        /**
         * 两条线段之间的距离
         * @param ls1
         * @param ls2
         * @returns {number}
         * @constructor
         */
        value: function lineSegmentToLineSegment(ls1, ls2) {

            return 0;
        }
    }, {
        key: 'pointToLineSegment',

        /**
         * 点到线段的距离
         * @param p
         * @param ls
         * @returns {number}
         */
        value: function pointToLineSegment(p, ls) {
            //点是否在线段上
            if (ls.isPointInLineSegment) {
                return 0;
            } else {
                //根据r值来判断P点在AB上的投影是否在线段上
                var AB = ls.toVector2();
                var AP = p.toVector2().sub(ls.p1);
                var len = ls.length;
                var r = AP.dot(AB) / (len * len);
                if (r >= 1) {
                    return Distance.pointToPoint(p, ls.p2);
                } else if (r <= 0) {
                    return Distance.pointToPoint(p, ls.p1);
                } else {
                    var intersection = ls.p1.toVector2().lerp(ls.p2.toVector2(), r);
                    return Distance.pointToPoint(p, intersection);
                }
            }
        }
    }, {
        key: 'pointToCircle',

        /**
         * 点到圆的距离
         * @param p
         * @param c
         * @returns {number}
         */
        value: function pointToCircle(p, c) {
            return 0;
        }
    }]);

    return Distance;
}();

exports.Distance = Distance;
},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Intersection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Point = require('../geom/Point');

var _Triangle = require('../geom/Triangle');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Intersection = function () {
    function Intersection() {
        _classCallCheck(this, Intersection);

        throw new Error('Instantiation is not allowed!');
    }

    /**
     * 两条直线之间的交点
     * @param l1
     * @param l2
     * @returns {*}
     */


    _createClass(Intersection, null, [{
        key: 'lineToLine',
        value: function lineToLine(l1, l2) {
            //平行
            if (l1.k === l2.k) {
                return null;
            }
            //两条线中有一条垂直
            else if (l1.isVertical || l2.isVertical) {
                    return new _Point.Point(l1.isVertical ? l1.x : l2.x, l1.isVertical ? l2.k * l1.x + l2.b : l1.k * l2.x + l1.b);
                } else {
                    var k1 = l1.k;
                    var b1 = l1.b;
                    var k2 = l2.k;
                    var b2 = l2.b;
                    var x = (b2 - b1) / (k1 - k2);
                    return new _Point.Point(x, k1 * x + b1);
                }
        }

        /**
         * 是否两条线段相交
         * @param ls1
         * @param ls2
         * @returns {boolean}
         */

    }, {
        key: 'isTwoLineSegmentIntersect',
        value: function isTwoLineSegmentIntersect(ls1, ls2) {
            //AB为线段ls1的两个端点，CD为线段ls2的两个端点
            var A = ls1.p1.toVector2();
            var B = ls1.p2.toVector2();
            var C = ls2.p1.toVector2();
            var D = ls2.p2.toVector2();
            var ABXAC = B.sub(A).crossValue(C.sub(A));
            var ABXAD = B.sub(A).crossValue(D.sub(A));
            var CDXCA = D.sub(C).crossValue(A.sub(C));
            var CDXCB = D.sub(C).crossValue(B.sub(C));

            //todo 没考虑共线的情况
            return !!(ABXAC * ABXAD < 0 && CDXCA && CDXCB < 0);
        }

        /**
         * 两条线段的交点
         * @param ls1
         * @param ls2
         * @returns {Point}
         */

    }, {
        key: 'lineSegmentToLineSegment',
        value: function lineSegmentToLineSegment(ls1, ls2) {
            if (Intersection.isTwoLineSegmentIntersect(ls1, ls2)) {
                var A = ls1.p1;
                var B = ls1.p2;
                var C = ls2.p1;
                var D = ls2.p2;
                var ABD = new _Triangle.Triangle(A.x, A.y, B.x, B.y, D.x, D.y);
                var ABC = new _Triangle.Triangle(A.x, A.y, B.x, B.y, C.x, C.y);
                var n = ABD.area / ABC.area;
                var px = (D.x + n * C.x) / (1 + n);
                var py = ls1.k * px + ls1.b;
                return new _Point.Point(px, py);
            }
            return null;
        }
    }]);

    return Intersection;
}();

exports.Intersection = Intersection;
},{"../geom/Point":3,"../geom/Triangle":4}],8:[function(require,module,exports){
"use strict";

var _Point = require("../coniferCone/geom/Point");

var _Line = require("../coniferCone/geom/Line");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Created by work on 2017/2/21.
                                                                                                                                                           */

/**
 * 交点和角度
 */
var IntersectionAndAngle = function IntersectionAndAngle(intersection, angle) {
    _classCallCheck(this, IntersectionAndAngle);

    this.intersection = intersection;
    this.angle = angle;
};

main();
function main() {

    var canvas = document.getElementsByTagName('canvas')[0];
    var startP = new _Point.Point(),
        endP = new _Point.Point(),
        shape = void 0,
        shapes = new Map();
    //绘制交点
    var intersectionShape = new createjs.Shape();
    //角度文本集合
    var angleContainer = new createjs.Container();

    var data = {
        drawOption: 'line'
    };

    var ui = new dat.GUI();
    World.add(data, 'drawOption', ['line']);

    var stage = new createjs.Stage(canvas);
    createjs.Ticker.setFPS(60);
    createjs.Ticker.addEventListener('tick', stage);

    stage.addChild(intersectionShape);
    stage.addChild(angleContainer);

    stage.addEventListener('stagemousedown', onStageMouseDown);

    function onStageMouseDown(e) {
        stage.addEventListener('stagemousemove', onStageMouseMove);
        stage.addEventListener('stagemouseup', onStageMouseUp);
        startP.setValues(e.stageX, e.stageY);
        shape = new createjs.Shape();
        stage.addChild(shape);
    }

    function onStageMouseMove(e) {
        endP.setValues(e.stageX, e.stageY);
        draw();
    }

    function onStageMouseUp(e) {
        stage.removeEventListener('stagemousemove', onStageMouseMove);
        stage.removeEventListener('stagemouseup', onStageMouseUp);

        endP.setValues(e.stageX, e.stageY);
        draw();

        if (startP.distance(endP) < 4) {
            stage.removeChild(shape);
        } else {
            shapes.set(shape, new _Line.Line(startP.x, startP.y, endP.x, endP.y));
            drawIntersection();
        }
        startP.setValues(0, 0);
        endP.setValues(0, 0);
    }

    /**
     * 绘制直线间的交点
     */
    function drawIntersection() {
        var intersections = [];
        var keys = [].concat(_toConsumableArray(shapes.keys()));
        for (var i = 0; i < keys.length; i++) {
            var l1 = shapes.get(keys[i]);
            for (var j = i + 1; j < keys.length; j++) {
                var l2 = shapes.get(keys[j]);
                var intersection = l1.getLineIntersection(l2);
                if (intersection !== null) {
                    var _data = new IntersectionAndAngle(intersection, l1.getIntersectionAngle(l2));
                    intersections.push(_data);
                }
            }
        }

        var g = intersectionShape.graphics;
        g.clear();
        g.setStrokeStyle(1);

        intersections.forEach(function (value) {
            var intersection = value.intersection;
            var angle = value.angle.toFixed(2);
            var txt = new createjs.Text(angle, '12px Arial', 'blue');
            g.beginStroke('red');
            g.drawCircle(intersection.x, intersection.y, 4);
            angleContainer.addChild(txt);
            txt.x = intersection.x;
            txt.y = intersection.y;

            g.endStroke();
        });
    }

    function draw() {
        var g = shape.graphics;

        g.clear();
        g.setStrokeStyle(1);
        g.beginStroke('black');

        switch (data.drawOption) {
            case 'line':
                {
                    var x = startP.x;
                    var y = startP.y;
                    var k = (endP.y - y) / (endP.x - x);
                    var b = y - x * k;
                    var MAX = 9999;

                    if (k === Infinity || k === -Infinity) {
                        g.moveTo(x, -MAX);
                        g.lineTo(x, MAX);
                    } else {
                        g.moveTo(-MAX, -MAX * k + b);
                        g.lineTo(MAX, MAX * k + b);
                    }
                }
                break;
            case 'lineSegment':
                {
                    var _x = startP.x;
                    var _y = startP.y;
                    shape.x = _x;
                    shape.y = _y;
                    g.moveTo(0, 0);
                    g.lineTo(endP.x - _x, endP.y - _y);
                }
                break;
            case 'ellipse':
                {
                    var w = endP.x - startP.x;
                    var h = endP.y - startP.y;
                    shape.x = startP.x;
                    shape.y = startP.y;
                    g.drawEllipse(0, 0, w, h);
                }
                break;
            case 'circle':
                {
                    var _w = endP.x - startP.x;
                    var _h = endP.y - startP.y;
                    var offsetX = _w / 2;
                    var offsetY = _h / 2;
                    var radius = Math.sqrt(Math.pow(_w, 2) + Math.pow(_h, 2)) / 2;
                    shape.x = startP.x + offsetX;
                    shape.y = startP.y + offsetY;
                    g.drawCircle(0, 0, radius);
                    break;
                }
            case 'rectangle':
                {
                    var _w2 = endP.x - startP.x;
                    var _h2 = endP.y - startP.y;
                    shape.x = startP.x;
                    shape.y = startP.y;
                    g.drawRect(0, 0, _w2, _h2);
                }
                break;

        }
    }
}
},{"../coniferCone/geom/Line":2,"../coniferCone/geom/Point":3}]},{},[8])